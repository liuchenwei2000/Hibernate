
事务（Transaction）是一个逻辑工作单元，它包括一系列的操作。

事务包含4个基本特性，即ACID：

Atomic 原子性
事务中包含的操作被看作一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。

Consistency 一致性
只有合法的数据可以被写入数据库，如果数据有任何违例则事务应该回滚到最初状态。

Isolation 隔离性
事务允许多个用户对同一个数据的并发访问，而不破坏数据的正确性和完整性。
同时，并行事务的修改必须与其他并行事务的修改相互独立。

Durability 持久性
事务结束后，事务处理的结果必须能够得到固化（保存在可掉电存储器上）。


事务隔离是指，数据库通过某种机制，在并行的多个事务之间进行分隔，使每个事务在其执行过程中保持独立。（如同当前只有此事务单独运行）

背景：数据操作过程中可能出现的3种不确定情况

1，脏读（Dirty Reads）
一个事务读取了另一个并行事务未提交的数据。
2，不可重复读（Non-repeatable Reads）
一个事务再次读取之前曾读取过的数据时，发现该数据已经被另一个已提交的事务修改。
3，虚读（Phantom Reads）
一个事务重新执行了一个查询，返回的查询结果中包含了因为其他事务刚提交而产生的新纪录。

为了避免上述3种情况，标准SQL规范中，定义了如下4个事务隔离等级：
1，Read Uncommitted
最低级的事务隔离，仅仅保证不会读取到非法数据，上述3种情况都可能发生。
2，Read Committed
保证一个事务不会读到另一个并行事务已修改但未提交的数据，避免了脏读。
此事务隔离等级是大多数主流数据库的默认事务等级，同时也适用于大多数系统。
3，Repeatable Reads
保证一个事务不可能更新已经由另一个事务读取但未提交（回滚）的数据。
避免了脏读和不可重复读情况，但并不能完全保证数据的合法性（可能出现虚读），同时带来了更多的性能损失，
所以此事务隔离等级应用并不多。如果数据库由当前应用独享，那么完全可以通过乐观锁达到同样的目的。
4，Serializable
它将模拟事务的串行执行，逻辑上如同所有事务都处于一个执行队列，依次串行执行而非并行执行。
这是最高等级的事务隔离，上述3种情况都可以被规避，但也带来了高昂的性能开销。
如果确实需要，完全可以通过悲观锁机制实现。


业务逻辑的实现过程中，往往需要保证数据访问的排他性，所以需要通过一些机制来保证这些数据在某个操作过程中不会被外界修改
————这样的机制就是所谓的“锁”，即给选定的目标数据上锁，使其无法被其他程序修改。

Hibernate支持两种锁机制：即悲观锁（Pessimistic Locking）和乐观锁（Optimistic Locking）。
